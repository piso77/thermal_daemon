From 94ce373b64d90bf94db04c6db5d4323c8d43d920 Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Tue, 7 Jul 2020 16:46:31 -0700
Subject: [PATCH 116/134] Enforce PPCC min max time window

When PPCC max min time windows is specified, then use as follows:
- When both min and max windows are same, ignore
- When max is less than min ignore
- At power up along with max power setting set ppcc max time window
- Once contrained use mintime window
- Once constraint is removed restore back to max time window

Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
(cherry picked from commit 5ac93b04b61119d34a22ca1cde071850900e0fef)
Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
(cherry picked from commit 131aa2aa150b9ab1e368f3a6755f3c0bcba54327)
Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
---
 src/thd_cdev_rapl.cpp | 18 ++++++++++++++++--
 src/thd_cdev_rapl.h   |  3 ++-
 2 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/thd_cdev_rapl.cpp b/src/thd_cdev_rapl.cpp
index acd91aa..affcaa5 100644
--- a/src/thd_cdev_rapl.cpp
+++ b/src/thd_cdev_rapl.cpp
@@ -74,7 +74,10 @@ void cthd_sysfs_cdev_rapl::set_curr_state(int state, int control) {
 
 			// If it is the first time to activate this device, set the enabled flag
 			// and set the time window.
-			rapl_update_time_window(def_rapl_time_window);
+			if (pl0_min_window)
+				rapl_update_time_window(pl0_min_window);
+			else
+				rapl_update_time_window(def_rapl_time_window);
 
 			// Set enable flag only if it was disabled
 			if (!power_on_enable_status)
@@ -298,6 +301,9 @@ int cthd_sysfs_cdev_rapl::update() {
 
 		rapl_update_pl1(pl0_max_pwr);
 
+		if (pl0_max_window > pl0_min_window)
+			rapl_update_time_window(pl0_max_window);
+
 		// To be efficient to control from the current power instead of PPCC max.
 		thd_engine->rapl_power_meter.rapl_start_measure_power();
 		dynamic_phy_max_enable = true;
@@ -358,6 +364,7 @@ int cthd_sysfs_cdev_rapl::update() {
 	power_on_enable_status = rapl_read_enable_status();
 
 	thd_log_debug("power_on_enable_status: %d\n", power_on_enable_status);
+	thd_log_debug("power_on_constraint_0_time_window: %d\n", power_on_constraint_0_time_window);
 
 	thd_log_debug("RAPL max limit %d increment: %d\n", max_state, inc_dec_val);
 
@@ -379,6 +386,8 @@ bool cthd_sysfs_cdev_rapl::read_ppcc_power_limits() {
 		pl0_max_pwr = ppcc->power_limit_max * 1000;
 		pl0_min_pwr = ppcc->power_limit_min * 1000;
 		pl0_min_window = ppcc->time_wind_min * 1000;
+		pl0_min_window = ppcc->time_wind_min * 1000;
+		pl0_max_window = ppcc->time_wind_max * 1000;
 		pl0_step_pwr = ppcc->step_size * 1000;
 
 		if (pl0_max_pwr <= pl0_min_pwr) {
@@ -422,12 +431,17 @@ bool cthd_sysfs_cdev_rapl::read_ppcc_power_limits() {
 			return false;
 	}
 
+	if (sys_fs.exists("power_limit_0_tmax_us")) {
+		if (sys_fs.read("power_limit_0_tmax_us", &pl0_max_window) <= 0)
+			return false;
+	}
+
 	if (sys_fs.exists("power_limit_0_step_uw")) {
 		if (sys_fs.read("power_limit_0_step_uw", &pl0_step_pwr) <= 0)
 			return false;
 	}
 
-	if (pl0_max_pwr && pl0_min_pwr && pl0_min_window && pl0_step_pwr) {
+	if (pl0_max_pwr && pl0_min_pwr && pl0_min_window && pl0_step_pwr && pl0_max_window) {
 		int def_max_power;
 
 		if (pl0_max_pwr <= pl0_min_pwr) {
diff --git a/src/thd_cdev_rapl.h b/src/thd_cdev_rapl.h
index f2070bd..51b4899 100644
--- a/src/thd_cdev_rapl.h
+++ b/src/thd_cdev_rapl.h
@@ -37,6 +37,7 @@ protected:
 	int pl0_max_pwr;
 	int pl0_min_pwr;
 	int pl0_min_window;
+	int pl0_max_window;
 	int pl0_step_pwr;
 	bool bios_locked;
 	bool constrained;
@@ -71,7 +72,7 @@ public:
 					0), package_id(package), constraint_index(
 					0), dynamic_phy_max_enable(
 					false), pl0_max_pwr(0), pl0_min_pwr(0), pl0_min_window(
-					0), pl0_step_pwr(
+					0), pl0_max_window(0), pl0_step_pwr(
 					0), bios_locked(false), constrained(
 					false), power_on_constraint_0_pwr(0), power_on_constraint_0_time_window(
 					0), power_on_enable_status(0), device_name("TCPU.D0")
-- 
2.27.0

