From cfa5fa7b56a24b2a3fae2ab53ccba5e263be6be9 Mon Sep 17 00:00:00 2001
From: Matthew Garrett <mjg59@google.com>
Date: Sun, 12 Apr 2020 15:41:53 -0700
Subject: [PATCH 041/134] Handle multi-entry PSVT tables

PSVT tables may contain multiple passive trip points. Add support for that.

(cherry picked from commit 37964c6e98f193517399279be1c0e0bd88e60b1d)
Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
(cherry picked from commit 3ff88002319d473ebee28c17c02a5008471dff41)
Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
---
 src/thd_engine_adaptive.cpp | 171 ++++++++++++++++++++----------------
 src/thd_engine_adaptive.h   |   8 +-
 2 files changed, 103 insertions(+), 76 deletions(-)

diff --git a/src/thd_engine_adaptive.cpp b/src/thd_engine_adaptive.cpp
index 40af16b..f95b2e9 100644
--- a/src/thd_engine_adaptive.cpp
+++ b/src/thd_engine_adaptive.cpp
@@ -287,22 +287,28 @@ int cthd_engine_adaptive::parse_psvt(char *name, char *buf, int len) {
 		psvt.name = "Default";
 	else
 		psvt.name = name;
-	psvt.source = get_string(buf, &offset);
-	psvt.target = get_string(buf, &offset);
-	psvt.priority = get_uint64(buf, &offset);
-	psvt.sample_period = get_uint64(buf, &offset);
-	psvt.temp = get_uint64(buf, &offset);
-	psvt.domain = get_uint64(buf, &offset);
-	psvt.control_knob = get_uint64(buf, &offset);
-	if (get_type(buf, &offset) == 8) {
-		psvt.limit = get_string(buf, &offset);
-	} else {
-		uint64_t tmp = get_uint64(buf, &offset);
-		psvt.limit = std::to_string(tmp);
+	while (offset < len) {
+		struct psv psv;
+
+		psv.source = get_string(buf, &offset);
+		psv.target = get_string(buf, &offset);
+		psv.priority = get_uint64(buf, &offset);
+		psv.sample_period = get_uint64(buf, &offset);
+		psv.temp = get_uint64(buf, &offset);
+		psv.domain = get_uint64(buf, &offset);
+		psv.control_knob = get_uint64(buf, &offset);
+		if (get_type(buf, &offset) == 8) {
+			psv.limit = get_string(buf, &offset);
+		} else {
+			uint64_t tmp = get_uint64(buf, &offset);
+			psv.limit = std::to_string(tmp);
+		}
+		psv.step_size = get_uint64(buf, &offset);
+		psv.limit_coeff = get_uint64(buf, &offset);
+		psv.unlimit_coeff = get_uint64(buf, &offset);
+		offset += 12;
+		psvt.psvs.push_back(psv);
 	}
-	psvt.step_size = get_uint64(buf, &offset);
-	psvt.limit_coeff = get_uint64(buf, &offset);
-	psvt.unlimit_coeff = get_uint64(buf, &offset);
 
 	psvts.push_back(psvt);
 
@@ -543,77 +549,92 @@ struct psvt *cthd_engine_adaptive::find_psvt(std::string name) {
 	return NULL;
 }
 
-void cthd_engine_adaptive::set_int3400_target(struct adaptive_target target) {
-	struct psvt *psvt;
-	if (target.code == "PSVT") {
-		psvt = find_psvt(target.argument);
-		if (!psvt) {
-			return;
-		}
-		std::string psv_zone;
-		size_t pos = psvt->target.find_last_of(".");
-		if (pos == std::string::npos)
-			psv_zone = psvt->target;
-		else
-			psv_zone = psvt->target.substr(pos + 1);
-
-		cthd_zone *zone = search_zone(psv_zone);
-		if (!zone)
-			return;
+int cthd_engine_adaptive::install_passive(struct psv *psv) {
+	std::string psv_zone;
 
-		std::string psv_cdev;
-		pos = psvt->source.find_last_of(".");
-		if (pos == std::string::npos)
-			psv_cdev = psvt->source;
-		else
-			psv_cdev = psvt->source.substr(pos + 1);
+	size_t pos = psv->target.find_last_of(".");
+	if (pos == std::string::npos)
+		psv_zone = psv->target;
+	else
+		psv_zone = psv->target.substr(pos + 1);
 
-		cthd_cdev *cdev = search_cdev(psv_cdev);
+	cthd_zone *zone = search_zone(psv_zone);
+	if (!zone) {
+		thd_log_warn("Unable to find a zone for %s\n", psv_zone.c_str());
+		return THD_ERROR;
+	}
 
-		// HACK - if the cdev is RAPL and the sensor is memory, use
-		// the rapl-dram device instead
-		if (psv_zone == "TMEM" && psv_cdev == "B0D4")
-			cdev = search_cdev("rapl_controller_dram");
+	std::string psv_cdev;
+	pos = psv->source.find_last_of(".");
+	if (pos == std::string::npos)
+		psv_cdev = psv->source;
+	else
+		psv_cdev = psv->source.substr(pos + 1);
 
-		if (!cdev)
-			return;
+	cthd_cdev *cdev = search_cdev(psv_cdev);
 
-		cthd_sensor *sensor = search_sensor(psv_zone);
-		if (!sensor)
-			return;
+	// HACK - if the cdev is RAPL and the sensor is memory, use the
+	// rapl-dram device instead
+	if (psv_zone == "TMEM" && psv_cdev == "B0D4")
+		cdev = search_cdev("rapl_controller_dram");
+
+	if (!cdev) {
+		thd_log_warn("Unable to find a cooling device for %s\n", psv_cdev.c_str());
+		return THD_ERROR;
+	}
+
+	cthd_sensor *sensor = search_sensor(psv_zone);
+	if (!sensor) {
+		thd_log_warn("Unable to find a sensor for %s\n", psv_zone.c_str());
+		return THD_ERROR;
+	}
 
-		int temp = (psvt->temp - 2732) * 100;
-		int index = 0;
-		cthd_trip_point *trip = zone->get_trip_at_index(index);
-		while (trip != NULL) {
-			trip->trip_dump();
-			if (trip->get_trip_type() == PASSIVE) {
-				int cdev_index = 0;
-				while (true) {
-					try {
-						trip_pt_cdev_t trip_cdev = trip->get_cdev_at_index(cdev_index);
-						if (trip_cdev.cdev == cdev) {
-							trip->update_trip_temp(temp);
-							return;
-						}
-						cdev_index++;
-					} catch (const std::invalid_argument &) {
-						break;
+	int temp = (psv->temp - 2732) * 100;
+	int index = 0;
+	cthd_trip_point *trip = zone->get_trip_at_index(index);
+	while (trip != NULL) {
+		trip->trip_dump();
+		if (trip->get_trip_type() == PASSIVE) {
+			int cdev_index = 0;
+			while (true) {
+				try {
+					trip_pt_cdev_t trip_cdev = trip->get_cdev_at_index(cdev_index);
+					if (trip_cdev.cdev == cdev) {
+						trip->update_trip_temp(temp);
+						return 0;
 					}
+					cdev_index++;
+				} catch (const std::invalid_argument &) {
+					break;
 				}
 			}
-			index++;
-			trip = zone->get_trip_at_index(index);
 		}
+		index++;
+		trip = zone->get_trip_at_index(index);
+	}
+
+	// If we're here, there's no existing trip point for this device
+	// that includes the relevant cdev. Add one.
+	cthd_trip_point trip_pt(index, PASSIVE, temp, 0,
+				zone->get_zone_index(),
+				sensor->get_index());
+	trip_pt.thd_trip_point_add_cdev(*cdev, cthd_trip_point::default_influence, psv->sample_period/10);
+	zone->add_trip(trip_pt);
+	zone->zone_cdev_set_binded();
 
-		// If we're here, there's no existing trip point for this
-		// device that includes the relevant cdev. Add one.
-		cthd_trip_point trip_pt(index, PASSIVE, temp, 0,
-					zone->get_zone_index(),
-					sensor->get_index());
-		trip_pt.thd_trip_point_add_cdev(*cdev, cthd_trip_point::default_influence, psvt->sample_period/10);
-		zone->add_trip(trip_pt);
-		zone->zone_cdev_set_binded();
+	return 0;
+}
+
+void cthd_engine_adaptive::set_int3400_target(struct adaptive_target target) {
+	struct psvt *psvt;
+	if (target.code == "PSVT") {
+		psvt = find_psvt(target.argument);
+		if (!psvt) {
+			return;
+		}
+		for (int i = 0; i < (int)psvt->psvs.size(); i++) {
+			install_passive(&psvt->psvs[i]);
+		}
 	}
 }
 
diff --git a/src/thd_engine_adaptive.h b/src/thd_engine_adaptive.h
index 3241662..1c824c0 100644
--- a/src/thd_engine_adaptive.h
+++ b/src/thd_engine_adaptive.h
@@ -97,7 +97,7 @@ enum adaptive_operation {
 	FOR
 };
 
-struct psvt {
+struct psv {
 	std::string name;
 	std::string source;
 	std::string target;
@@ -133,6 +133,11 @@ struct custom_condition {
 	int type;
 };
 
+struct psvt {
+	std::string name;
+	std::vector<struct psv> psvs;
+};
+
 class cthd_engine_adaptive: public cthd_engine_default {
 protected:
 	std::vector<ppcc_t> ppccs;
@@ -154,6 +159,7 @@ protected:
 	int handle_compressed_gddv(char *buf, int size);
 	int parse_gddv(char *buf, int size);
 	struct psvt *find_psvt(std::string name);
+	int install_passive(struct psv *psv);
 	void set_int3400_target(struct adaptive_target target);
 	int verify_condition(struct condition condition);
 	int verify_conditions();
-- 
2.27.0

