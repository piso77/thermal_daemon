From 92131b53c74f11f724e26678d09a6642b792c807 Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Mon, 5 May 2014 16:18:13 -0700
Subject: [PATCH 5/5] Adjust for coretemp path change

Linux kernel 3.14 and beyond the temp data is no longer available
for CPUs in /sys/devices/platform/coretemp.0.
Instead we need to read from /sys/class/hwmon/hwmonX for matching
name = coretemp.
This change also makes sure that it also searches the old path
for older kernels.
---
 src/thd_engine_default.cpp | 143 +++++++++++++++++++++++++++++++--------------
 1 file changed, 99 insertions(+), 44 deletions(-)

diff --git a/src/thd_engine_default.cpp b/src/thd_engine_default.cpp
index 0176c5a..24b2d0d 100644
--- a/src/thd_engine_default.cpp
+++ b/src/thd_engine_default.cpp
@@ -89,7 +89,9 @@ int cthd_engine_default::read_thermal_sensors() {
 	struct dirent *entry;
 	int sensor_mask = 0x0f;
 	cthd_sensor *sensor;
-	const std::string base_path = "/sys/devices/platform/";
+	const std::string base_path[] = { "/sys/devices/platform/",
+			"/sys/class/hwmon/" };
+	int i;
 
 	thd_read_default_thermal_sensors();
 	index = sensor_count;
@@ -101,38 +103,62 @@ int cthd_engine_default::read_thermal_sensors() {
 	}
 	// Default CPU temperature zone
 	// Find path to read DTS temperature
-	if ((dir = opendir(base_path.c_str())) != NULL) {
-		while ((entry = readdir(dir)) != NULL) {
-			if (!strncmp(entry->d_name, "coretemp.", strlen("coretemp."))) {
-				int cnt = 0;
-				unsigned int mask = 0x1;
-				do {
-					if (sensor_mask & mask) {
-						std::stringstream temp_input_str;
-						std::string path = base_path + entry->d_name + "/";
-						csys_fs dts_sysfs(path.c_str());
-						temp_input_str << "temp" << cnt << "_input";
-						if (dts_sysfs.exists(temp_input_str.str())) {
-							cthd_sensor *sensor = new cthd_sensor(index,
-									base_path + entry->d_name + "/"
-											+ temp_input_str.str(),
-									temp_input_str.str(), SENSOR_TYPE_RAW);
-							if (sensor->sensor_update() != THD_SUCCESS) {
-								delete sensor;
-								closedir(dir);
-								return THD_ERROR;
-							}
-							sensors.push_back(sensor);
-							++index;
-						}
+	for (i = 0; i < 2; ++i) {
+		if ((dir = opendir(base_path[i].c_str())) != NULL) {
+			while ((entry = readdir(dir)) != NULL) {
+				if (!strncmp(entry->d_name, "coretemp.", strlen("coretemp."))
+						|| !strncmp(entry->d_name, "hwmon", strlen("hwmon"))) {
+
+					// Check name
+					std::string name_path = base_path[i] + entry->d_name
+							+ "/name";
+					csys_fs name_sysfs(name_path.c_str());
+					if (!name_sysfs.exists()) {
+						thd_log_info("dts %s doesn't exist\n",
+								name_path.c_str());
+						continue;
 					}
-					mask = (mask << 1);
-					cnt++;
-				} while (mask != 0);
+					std::string name;
+					if (name_sysfs.read("", name) < 0) {
+						thd_log_info("dts name read failed for %s\n",
+								name_path.c_str());
+						continue;
+					}
+					if (name != "coretemp")
+						continue;
 
+					int cnt = 0;
+					unsigned int mask = 0x1;
+					do {
+						if (sensor_mask & mask) {
+							std::stringstream temp_input_str;
+							std::string path = base_path[i] + entry->d_name
+									+ "/";
+							csys_fs dts_sysfs(path.c_str());
+							temp_input_str << "temp" << cnt << "_input";
+							if (dts_sysfs.exists(temp_input_str.str())) {
+								cthd_sensor *sensor = new cthd_sensor(index,
+										base_path[i] + entry->d_name + "/"
+												+ temp_input_str.str(),
+												"hwmon", SENSOR_TYPE_RAW);
+								if (sensor->sensor_update() != THD_SUCCESS) {
+									delete sensor;
+									closedir(dir);
+									return THD_ERROR;
+								}
+								sensors.push_back(sensor);
+								++index;
+							}
+						}
+						mask = (mask << 1);
+						cnt++;
+					} while (mask != 0);
+				}
 			}
+			closedir(dir);
 		}
-		closedir(dir);
+		if (index != sensor_count)
+			break;
 	}
 	if (index == sensor_count) {
 		// No coretemp sysfs exist, try hwmon
@@ -191,7 +217,9 @@ int cthd_engine_default::read_thermal_zones() {
 	int count = 0;
 	DIR *dir;
 	struct dirent *entry;
-	const std::string base_path = "/sys/devices/platform/";
+	const std::string base_path[] = { "/sys/devices/platform/",
+			"/sys/class/hwmon/" };
+	int i;
 
 	thd_read_default_thermal_zones();
 	count = zone_count;
@@ -201,23 +229,50 @@ int cthd_engine_default::read_thermal_zones() {
 		thd_log_info("zone cpu will be created \n");
 		// Default CPU temperature zone
 		// Find path to read DTS temperature
-		if ((dir = opendir(base_path.c_str())) != NULL) {
-			while ((entry = readdir(dir)) != NULL) {
-				if (!strncmp(entry->d_name, "coretemp.", strlen("coretemp."))) {
-					cthd_zone_cpu *zone = new cthd_zone_cpu(count,
-							base_path + entry->d_name + "/",
-							atoi(entry->d_name + strlen("coretemp.")));
-					if (zone->zone_update() == THD_SUCCESS) {
-						zone->set_zone_active();
-						zones.push_back(zone);
-						++count;
-						cpu_zone_created = true;
-					} else {
-						delete zone;
+		for (i = 0; i < 2; ++i) {
+			if ((dir = opendir(base_path[i].c_str())) != NULL) {
+				while ((entry = readdir(dir)) != NULL) {
+					if (!strncmp(entry->d_name, "coretemp.",
+							strlen("coretemp."))
+							|| !strncmp(entry->d_name, "hwmon",
+									strlen("hwmon"))) {
+
+						std::string name_path = base_path[i] + entry->d_name
+								+ "/name";
+						csys_fs name_sysfs(name_path.c_str());
+						if (!name_sysfs.exists()) {
+							thd_log_info("dts zone %s doesn't exist\n",
+									name_path.c_str());
+							continue;
+						}
+						std::string name;
+						if (name_sysfs.read("", name) < 0) {
+							thd_log_info("dts zone name read failed for %s\n",
+									name_path.c_str());
+							continue;
+						}
+						thd_log_info("%s->%s\n", name_path.c_str(),
+								name.c_str());
+						if (name != "coretemp")
+							continue;
+
+						cthd_zone_cpu *zone = new cthd_zone_cpu(count,
+								base_path[i] + entry->d_name + "/",
+								atoi(entry->d_name + strlen("coretemp.")));
+						if (zone->zone_update() == THD_SUCCESS) {
+							zone->set_zone_active();
+							zones.push_back(zone);
+							++count;
+							cpu_zone_created = true;
+						} else {
+							delete zone;
+						}
 					}
 				}
+				closedir(dir);
 			}
-			closedir(dir);
+			if (cpu_zone_created)
+				break;
 		}
 #ifdef ACTIVATE_SURFACE
 //	Enable when skin sensors are standardized
-- 
2.0.0.rc0

