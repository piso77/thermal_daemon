From 29b741f450d8bbbd153ebf5156f80678c2c78abd Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Tue, 20 Oct 2015 13:04:44 -0700
Subject: [PATCH] Support target state

When multiple trips are defined for same cdev, it is likely that
they want to limit the compensation for each trip to a value.

For example in the below config file, when temperature reaches
40c, the max limit is 3 and when 50 it is 6 and when 60 it
is like current without any target state and will only be limited
by the max state.
<?xml version="1.0"?>
<!--
This test configuration tests how target state can be set. Here we also
test if multiple target state for multiple trips to the same cooling
device. Here two trips have target state the last trip doesn't have
any target state and will go upto max. Make sure that system behaves
any temperature chage"
- 40 to 50 to 60
- Directly to 60
- Wild wings between 10 to 60C
-->
       <ThermalConfiguration>
		<Platform>
                 <Name>THD_TEST_0</Name>
                 <ProductName>*</ProductName>
                 <Preference>QUIET</Preference>
                 <ThermalZones>
                      <ThermalZone>
                           <Type>thd_test_ex_0</Type>
                           <TripPoints>
                                     <TripPoint>
                                          <SensorType>thd_test_0</SensorType>
                                          <Temperature>40000</Temperature>
                                          <type>passive</type>
                                     	<CoolingDevice>
                                          <Type>thd_cdev_0</Type>
					  <TargetState> 3 </TargetState>
                                     	</CoolingDevice>
                                     </TripPoint>
                                     <TripPoint>
                                          <SensorType>thd_test_0</SensorType>
                                          <Temperature>50000</Temperature>
                                          <type>passive</type>
                                     	<CoolingDevice>
                                          <Type>thd_cdev_0</Type>
					  <TargetState> 6 </TargetState>
                                     	</CoolingDevice>
                                     </TripPoint>
                                     <TripPoint>
                                          <SensorType>thd_test_0</SensorType>
                                          <Temperature>60000</Temperature>
                                          <type>passive</type>
                                     	<CoolingDevice>
                                          <Type>thd_cdev_0</Type>
                                     	</CoolingDevice>
                                     </TripPoint>

                           </TripPoints>
                      </ThermalZone>
                 </ThermalZones>
            </Platform>
       </ThermalConfiguration>
---
 src/thd_cdev.cpp           | 111 +++++++++++++++++++++++++++++++++++++++++----
 src/thd_cdev.h             |  33 +++++++++++++-
 src/thd_engine_default.cpp |   6 ++-
 src/thd_parse.cpp          |  13 +++++-
 src/thd_parse.h            |   1 +
 src/thd_trip_point.cpp     |  18 ++++++--
 src/thd_trip_point.h       |   5 +-
 src/thd_zone.cpp           |   9 ++--
 src/thd_zone.h             |   3 +-
 src/thd_zone_generic.cpp   |   3 +-
 10 files changed, 178 insertions(+), 24 deletions(-)

diff --git a/src/thd_cdev.cpp b/src/thd_cdev.cpp
index 109874e..569afaa 100644
--- a/src/thd_cdev.cpp
+++ b/src/thd_cdev.cpp
@@ -59,8 +59,8 @@ int cthd_cdev::thd_cdev_exponential_controller(int set_point, int target_temp,
 				++curr_pow;
 				state = base_pow_state + int_2_pow(curr_pow) * inc_dec_val;
 				thd_log_info(
-						"consecutive call, increment exponentially state %d\n",
-						state);
+						"cdev index:%d consecutive call, increment exponentially state %d\n",
+						index, state);
 				if ((min_state < max_state && state >= max_state)
 						|| (min_state > max_state && state <= max_state)) {
 					state = max_state;
@@ -96,23 +96,51 @@ int cthd_cdev::thd_cdev_exponential_controller(int set_point, int target_temp,
 		}
 	}
 
-	thd_log_debug("Set : %d, %d, %d, %d, %d\n", set_point, temperature, index,
-			get_curr_state(), max_state);
+	thd_log_info(
+			"Set : threshold:%d, temperature:%d, cdev:%d(%s), curr_state:%d, max_state:%d\n",
+			set_point, temperature, index, type_str.c_str(), get_curr_state(),
+			max_state);
 
 	thd_log_debug("<<thd_cdev_set_state %d\n", state);
 
 	return THD_SUCCESS;
 }
 
+static bool sort_clamp_values(zone_trip_limits_t limit_1,
+		zone_trip_limits_t limit_2) {
+	return (limit_1.target_value < limit_2.target_value);
+}
+
+/*
+ * How the state is set?
+ * If the state set is called before debounce interval, then simply return
+ * success We have two mask zone_mask and trip_mask. The idea is that while
+ * any zone and trip has turned on then the other zone or trip can't reset
+ * unless it is the last one.
+ * In addition a zone trip can call for a particular target value for this
+ * cdev (When it doesn't want the exponential or pid control to use, this
+ * is true when multiple trips wants to use the cdev with different state
+ * values. They way we support this:
+ * When a valid target value is set then we push to a list, sorted using
+ * increasing target values. The passed target value is set, no check is
+ * done here to check the state higher/lower than the current state. This
+ * is done during trip_point_check class.
+ * When off is called for device, then we check if the zone in our list,
+ * if yes, we remove this zone and set the next higher value state from
+ * the list. If this is the current zone is the last then we remove
+ * the zone and set the state to minimum state.
+ */
+
 int cthd_cdev::thd_cdev_set_state(int set_point, int target_temp,
-		int temperature, int state, int zone_id, int trip_id) {
+		int temperature, int state, int zone_id, int trip_id,
+		int target_value) {
 
 	time_t tm;
 	int ret;
 
 	time(&tm);
-	thd_log_debug(">>thd_cdev_set_state index:%d state:%d :%d:%d\n", index,
-			state, zone_id, trip_id);
+	thd_log_debug(">>thd_cdev_set_state index:%d state:%d :%d:%d:%d\n", index,
+			state, zone_id, trip_id, target_value);
 	if (last_state == state && (tm - last_action_time) <= debounce_interval) {
 		thd_log_debug(
 				"Ignore: delay < debounce interval : %d, %d, %d, %d, %d\n",
@@ -123,6 +151,37 @@ int cthd_cdev::thd_cdev_set_state(int set_point, int target_temp,
 	if (state) {
 		zone_mask |= (1 << zone_id);
 		trip_mask |= (1 << trip_id);
+
+		if (target_value != TRIP_PT_INVALID_TARGET_STATE) {
+			zone_trip_limits_t limit;
+			bool found = false;
+
+			for (unsigned int i = 0; i < zone_trip_limits.size(); ++i) {
+				if (zone_trip_limits[i].zone == zone_id
+						&& zone_trip_limits[i].trip == trip_id) {
+					found = true;
+					break;
+				}
+			}
+			if (!found) {
+				limit.zone = zone_id;
+				limit.trip = trip_id;
+				limit.target_value = target_value;
+				thd_log_debug("Added zone %d trip %d clamp %d\n", limit.zone,
+						limit.trip, limit.target_value);
+				zone_trip_limits.push_back(limit);
+				std::sort(zone_trip_limits.begin(), zone_trip_limits.end(),
+						sort_clamp_values);
+			}
+			set_curr_state_raw(target_value, zone_id);
+			curr_state = target_value;
+			last_action_time = tm;
+			thd_log_info(
+					"Set : threshold:%d, temperature:%d, cdev:%d(%s), curr_state:%d, max_state:%d\n",
+					set_point, temperature, index, type_str.c_str(),
+					get_curr_state(), max_state);
+			return THD_SUCCESS;
+		}
 	} else {
 
 		if (zone_mask & (1 << zone_id)) {
@@ -131,7 +190,43 @@ int cthd_cdev::thd_cdev_set_state(int set_point, int target_temp,
 				zone_mask &= ~(1 << zone_id);
 			}
 		}
-		if (zone_mask != 0 || trip_mask != 0) {
+
+		if (zone_trip_limits.size() > 0) {
+			int length = zone_trip_limits.size();
+			int i;
+
+			// Just remove the current zone requesting to turn off
+			for (i = 0; i < length; ++i) {
+				if (zone_trip_limits[i].zone == zone_id
+						&& zone_trip_limits[i].trip == trip_id) {
+					zone_trip_limits.erase(zone_trip_limits.begin() + i);
+					thd_log_debug("Erased  [%d: %d\n", zone_id, trip_id);
+					break;
+				}
+			}
+			zone_trip_limits_t limit;
+
+			if (zone_trip_limits.size() == 0) {
+				limit.target_value = get_min_state();
+				limit.zone = zone_id;
+				limit.trip = trip_id;
+			} else {
+				limit = zone_trip_limits[zone_trip_limits.size() - 1];
+			}
+
+			if (cmp_current_state(limit.target_value) < 0) {
+				thd_log_info(
+						"new active zone; next in line  %d trip %d clamp %d\n",
+						limit.zone, limit.trip, limit.target_value);
+				set_curr_state_raw(limit.target_value, zone_id);
+				thd_log_info(
+						"Set : threshold:%d, temperature:%d, cdev:%d(%s), curr_state:%d, max_state:%d\n",
+						set_point, temperature, index, type_str.c_str(),
+						get_curr_state(), max_state);
+			}
+			return THD_SUCCESS;
+
+		} else if (zone_mask != 0 || trip_mask != 0) {
 			thd_log_debug(
 					"skip to reduce current state as this is controlled by two zone or trip actions and one is still on %lx:%lx\n",
 					zone_mask, trip_mask);
diff --git a/src/thd_cdev.h b/src/thd_cdev.h
index 9280d8e..dec4b3b 100644
--- a/src/thd_cdev.h
+++ b/src/thd_cdev.h
@@ -26,11 +26,20 @@
 #define THD_CDEV_H
 
 #include <time.h>
+#include <vector>
 #include "thd_common.h"
 #include "thd_sys_fs.h"
 #include "thd_preference.h"
 #include "thd_pid.h"
 
+typedef struct {
+	int zone;
+	int trip;
+	int target_value;
+} zone_trip_limits_t;
+
+#define ZONE_TRIP_LIMIT_COUNT	12
+
 class cthd_cdev {
 
 protected:
@@ -55,6 +64,7 @@ protected:
 	bool pid_enable;
 	cthd_pid pid_ctrl;
 	int last_state;
+	std::vector<zone_trip_limits_t> zone_trip_limits;
 
 private:
 	unsigned int int_2_pow(int pow) {
@@ -81,7 +91,8 @@ public:
 	virtual ~cthd_cdev() {
 	}
 	virtual int thd_cdev_set_state(int set_point, int target_temp,
-			int temperature, int state, int zone_id, int trip_id);
+			int temperature, int state, int zone_id, int trip_id,
+			int target_value);
 
 	virtual int thd_cdev_set_min_state(int zone_id);
 
@@ -163,6 +174,26 @@ public:
 		return false;
 	}
 
+	int cmp_current_state(int state) {
+		if (get_curr_state() == state)
+			return 0;
+
+		if (min_state < max_state) {
+			if (state > get_curr_state())
+				return 1;
+			else
+				return -1;
+		}
+
+		if (min_state > max_state) {
+			if (state > get_curr_state())
+				return -1;
+			else
+				return 1;
+		}
+		return 0;
+	}
+
 	std::string get_cdev_type() {
 		return type_str;
 	}
diff --git a/src/thd_engine_default.cpp b/src/thd_engine_default.cpp
index cac300a..40db7ae 100644
--- a/src/thd_engine_default.cpp
+++ b/src/thd_engine_default.cpp
@@ -361,7 +361,8 @@ int cthd_engine_default::read_thermal_zones() {
 							if (cdev) {
 								trip_pt.thd_trip_point_add_cdev(*cdev,
 										trip_pt_config.cdev_trips[j].influence,
-										trip_pt_config.cdev_trips[j].sampling_period);
+										trip_pt_config.cdev_trips[j].sampling_period,
+										trip_pt_config.cdev_trips[j].target_state);
 								zone->zone_cdev_set_binded();
 								activate = true;
 							}
@@ -385,7 +386,8 @@ int cthd_engine_default::read_thermal_zones() {
 								if (zone->bind_cooling_device(
 										trip_pt_config.trip_pt_type, 0, cdev,
 										trip_pt_config.cdev_trips[j].influence,
-										trip_pt_config.cdev_trips[j].sampling_period) == THD_SUCCESS) {
+										trip_pt_config.cdev_trips[j].sampling_period,
+										trip_pt_config.cdev_trips[j].target_state) == THD_SUCCESS) {
 									thd_log_debug(
 											"bind %s to trip to sensor %s\n",
 											cdev->get_cdev_type().c_str(),
diff --git a/src/thd_parse.cpp b/src/thd_parse.cpp
index 5c35f04..7f29d73 100644
--- a/src/thd_parse.cpp
+++ b/src/thd_parse.cpp
@@ -46,9 +46,9 @@ void cthd_parse::string_trim(std::string &str) {
 // Very simple version just checking for 0x20 not other white space chars
 bool isspace(int c) {
 	if (c == ' ')
-	return true;
+		return true;
 	else
-	return false;
+		return false;
 }
 #endif
 
@@ -126,6 +126,9 @@ int cthd_parse::parse_new_trip_cdev(xmlNode * a_node, xmlDoc *doc,
 			} else if (!strcasecmp((const char*) cur_node->name,
 					"SamplingPeriod")) {
 				trip_cdev->sampling_period = atoi(tmp_value);
+			} else if (!strcasecmp((const char*) cur_node->name,
+					"TargetState")) {
+				trip_cdev->target_state = atoi(tmp_value);
 			}
 			if (tmp_value)
 				xmlFree(tmp_value);
@@ -157,6 +160,7 @@ int cthd_parse::parse_new_trip_point(xmlNode * a_node, xmlDoc *doc,
 					"CoolingDevice")) {
 				trip_cdev.influence = 0;
 				trip_cdev.sampling_period = 0;
+				trip_cdev.target_state = TRIP_PT_INVALID_TARGET_STATE;
 				trip_cdev.type.clear();
 				parse_new_trip_cdev(cur_node->children, doc, &trip_cdev);
 				trip_pt->cdev_trips.push_back(trip_cdev);
@@ -635,6 +639,11 @@ void cthd_parse::dump_thermal_conf() {
 							thermal_info_list[i].zones[j].trip_pts[k].cdev_trips[l].influence);
 					thd_log_info("\t\t\t  SamplingPeriod %d \n",
 							thermal_info_list[i].zones[j].trip_pts[k].cdev_trips[l].sampling_period);
+					if (thermal_info_list[i].zones[j].trip_pts[k].cdev_trips[l].target_state
+							!= TRIP_PT_INVALID_TARGET_STATE)
+						thd_log_info("\t\t\t  TargetState %d \n",
+								thermal_info_list[i].zones[j].trip_pts[k].cdev_trips[l].target_state);
+
 				}
 			}
 		}
diff --git a/src/thd_parse.h b/src/thd_parse.h
index ecb382b..3b19a8e 100644
--- a/src/thd_parse.h
+++ b/src/thd_parse.h
@@ -71,6 +71,7 @@ typedef struct {
 	std::string type;
 	int influence;
 	int sampling_period;
+	int target_state;
 } trip_cdev_t;
 
 typedef struct {
diff --git a/src/thd_trip_point.cpp b/src/thd_trip_point.cpp
index 944747a..086537f 100644
--- a/src/thd_trip_point.cpp
+++ b/src/thd_trip_point.cpp
@@ -141,13 +141,21 @@ bool cthd_trip_point::thd_trip_point_check(int id, unsigned int read_temp,
 			}
 			thd_log_debug("cdev at index %d:%s\n", cdev->thd_cdev_get_index(),
 					cdev->get_cdev_type().c_str());
-			if (cdev->in_max_state()) {
+			/*
+			 * When the cdev is already in max state, we skip this cdev.
+			 * Also when the target state if any for the current trip is greater
+			 * or equal than the current state of the cdev, then also skip.
+			 */
+			if (cdev->in_max_state()
+					|| (cdevs[i].target_state != TRIP_PT_INVALID_TARGET_STATE
+							&& cdev->cmp_current_state(cdevs[i].target_state)
+									<= 0)) {
 				thd_log_debug("Need to switch to next cdev \n");
 				// No scope of control with this cdev
 				continue;
 			}
 			ret = cdev->thd_cdev_set_state(temp, temp, read_temp, 1, zone_id,
-					index);
+					index, cdevs[i].target_state);
 			if (control_type == SEQUENTIAL && ret == THD_SUCCESS) {
 				// Only one cdev activation
 				break;
@@ -166,7 +174,8 @@ bool cthd_trip_point::thd_trip_point_check(int id, unsigned int read_temp,
 				// No scope of control with this cdev
 				continue;
 			}
-			cdev->thd_cdev_set_state(temp, temp, read_temp, 0, zone_id, index);
+			cdev->thd_cdev_set_state(temp, temp, read_temp, 0, zone_id, index,
+					TRIP_PT_INVALID_TARGET_STATE);
 			if (control_type == SEQUENTIAL) {
 				// Only one cdev activation
 				break;
@@ -178,12 +187,13 @@ bool cthd_trip_point::thd_trip_point_check(int id, unsigned int read_temp,
 }
 
 void cthd_trip_point::thd_trip_point_add_cdev(cthd_cdev &cdev, int influence,
-		int sampling_period) {
+		int sampling_period, int target_state) {
 	trip_pt_cdev_t thd_cdev;
 	thd_cdev.cdev = &cdev;
 	thd_cdev.influence = influence;
 	thd_cdev.sampling_priod = sampling_period;
 	thd_cdev.last_op_time = 0;
+	thd_cdev.target_state = target_state;
 	trip_cdev_add(thd_cdev);
 }
 
diff --git a/src/thd_trip_point.h b/src/thd_trip_point.h
index 86598ee..a5d5de0 100644
--- a/src/thd_trip_point.h
+++ b/src/thd_trip_point.h
@@ -43,11 +43,13 @@ typedef enum {
 	SEQUENTIAL  // one after other once the previous cdev reaches its max state
 } trip_control_type_t;
 
+#define TRIP_PT_INVALID_TARGET_STATE	0xffffff
 typedef struct {
 	cthd_cdev *cdev;
 	int influence;
 	int sampling_priod;
 	time_t last_op_time;
+	int target_state;
 } trip_pt_cdev_t;
 
 #define DEFAULT_SENSOR_ID	0xFFFF
@@ -88,7 +90,8 @@ public:
 			bool *reset);
 
 	void thd_trip_point_add_cdev(cthd_cdev &cdev, int influence,
-			int sampling_period = 0);
+			int sampling_period = 0, int target_state =
+					TRIP_PT_INVALID_TARGET_STATE);
 
 	void thd_trip_cdev_state_reset();
 	int thd_trip_point_value() {
diff --git a/src/thd_zone.cpp b/src/thd_zone.cpp
index 29068ea..9f327fd 100644
--- a/src/thd_zone.cpp
+++ b/src/thd_zone.cpp
@@ -52,7 +52,7 @@ void cthd_zone::thermal_zone_temp_change(int id, unsigned int temp, int pref) {
 	bool reset = false;
 
 	count = trip_points.size();
-	for (i = count - 1; i >= 0; --i) {
+	for (i = 0; i < count; ++i) {
 		cthd_trip_point &trip_point = trip_points[i];
 		if (trip_point.get_trip_type() == MAX) {
 			thd_model.add_sample(zone_temp);
@@ -159,7 +159,8 @@ int cthd_zone::zone_update() {
 		unsigned int max_trip_temp = 0;
 
 		std::sort(trip_points.begin(), trip_points.end(), trip_sort);
-		thd_log_info("Sorted trip dump :\n");
+		thd_log_info("Sorted trip dump zone index:%d type:%s:\n", index,
+				type_str.c_str());
 		for (unsigned int i = 0; i < trip_points.size(); ++i) {
 			trip_points[i].trip_dump();
 		}
@@ -267,7 +268,7 @@ void cthd_zone::zone_reset() {
 
 int cthd_zone::bind_cooling_device(trip_point_type_t type,
 		unsigned int trip_temp, cthd_cdev *cdev, int influence,
-		int sampling_period) {
+		int sampling_period, int target_state) {
 	int i, count;
 	bool added = false;
 
@@ -279,7 +280,7 @@ int cthd_zone::bind_cooling_device(trip_point_type_t type,
 				&& (trip_point.get_trip_temp() > 0)
 				&& (trip_temp == 0 || trip_point.get_trip_temp() == trip_temp)) {
 			trip_point.thd_trip_point_add_cdev(*cdev, influence,
-					sampling_period);
+					sampling_period, target_state);
 			added = true;
 			zone_cdev_set_binded();
 			break;
diff --git a/src/thd_zone.h b/src/thd_zone.h
index 04b512f..5ae8719 100644
--- a/src/thd_zone.h
+++ b/src/thd_zone.h
@@ -153,7 +153,8 @@ public:
 	int read_user_set_psv_temp();
 
 	int bind_cooling_device(trip_point_type_t type, unsigned int trip_temp,
-			cthd_cdev *cdev, int influence, int sampling_period = 0);
+			cthd_cdev *cdev, int influence, int sampling_period = 0,
+			int target_state = TRIP_PT_INVALID_TARGET_STATE);
 
 	int get_sensor_count() {
 		return sensors.size();
diff --git a/src/thd_zone_generic.cpp b/src/thd_zone_generic.cpp
index e549c9a..389cad2 100644
--- a/src/thd_zone_generic.cpp
+++ b/src/thd_zone_generic.cpp
@@ -71,7 +71,8 @@ int cthd_zone_generic::read_trip_points() {
 			if (cdev) {
 				trip_pt.thd_trip_point_add_cdev(*cdev,
 						trip_pt_config.cdev_trips[j].influence,
-						trip_pt_config.cdev_trips[j].sampling_period);
+						trip_pt_config.cdev_trips[j].sampling_period,
+						trip_pt_config.cdev_trips[j].target_state);
 				zone_cdev_set_binded();
 			}
 		}
-- 
2.7.0.rc3

