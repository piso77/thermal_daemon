From a6f7c797753e7e7b48ee8677bd46a7133d4b8602 Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Sat, 13 Sep 2014 11:26:12 -0700
Subject: [PATCH] RT Linux lockup with x86 package temp driver

x86 package temp driver has issue as spin locks are preemptible in
RT Linux. When this driver is present, coretemp will be there, so
fallback to coretemp on RT Linux.
---
 src/thd_engine.cpp   | 30 +++++++++++++++++++++++++++++-
 src/thd_engine.h     |  7 +++++--
 src/thd_zone_cpu.cpp | 20 ++++++++++++--------
 3 files changed, 46 insertions(+), 11 deletions(-)

diff --git a/src/thd_engine.cpp b/src/thd_engine.cpp
index f0dddb3..e0f2aa1 100644
--- a/src/thd_engine.cpp
+++ b/src/thd_engine.cpp
@@ -34,6 +34,7 @@
 #include <dirent.h>
 #include <errno.h>
 #include <sys/types.h>
+#include <sys/utsname.h>
 #include <cpuid.h>
 #include <locale>
 #include "thd_engine.h"
@@ -49,7 +50,7 @@ cthd_engine::cthd_engine() :
 				0), preference(0), status(true), thz_last_time(0), terminate(
 				false), genuine_intel(0), has_invariant_tsc(0), has_aperf(0), proc_list_matched(
 				false), poll_interval_sec(0), poll_sensor_mask(0), poll_fd_cnt(
-				0) {
+				0), rt_kernel(false) {
 	thd_engine = pthread_t();
 	thd_attr = pthread_attr_t();
 	thd_cond_var = pthread_cond_t();
@@ -155,6 +156,8 @@ int cthd_engine::thd_engine_start(bool ignore_cpuid_check) {
 	} else
 		check_cpu_id();
 
+	check_for_rt_kernel();
+
 	// Pipe is used for communication between two processes
 	ret = pipe(wake_fds);
 	if (ret) {
@@ -776,3 +779,28 @@ cthd_zone* cthd_engine::get_zone(std::string type) {
 
 	return NULL;
 }
+
+// Code copied from
+// https://rt.wiki.kernel.org/index.php/RT_PREEMPT_HOWTO#Runtime_detection_of_an_RT-PREEMPT_Kernel
+void cthd_engine::check_for_rt_kernel() {
+	struct utsname _uname;
+	char *crit1 = NULL;
+	int crit2 = 0;
+	FILE *fd;
+
+	uname(&_uname);
+	crit1 = strcasestr(_uname.version, "PREEMPT RT");
+
+	if ((fd = fopen("/sys/kernel/realtime", "r")) != NULL) {
+		int flag;
+		crit2 = ((fscanf(fd, "%d", &flag) == 1) && (flag == 1));
+		fclose(fd);
+	}
+	if (crit1 && crit2)
+		rt_kernel = true;
+	else
+		rt_kernel = false;
+
+	thd_log_info("Running on a %s kernel\n",
+			rt_kernel ? "PREEMPT RT" : "vanilla");
+}
diff --git a/src/thd_engine.h b/src/thd_engine.h
index 1ae8bbe..53282fd 100644
--- a/src/thd_engine.h
+++ b/src/thd_engine.h
@@ -110,13 +110,14 @@ private:
 
 	struct pollfd poll_fds[THD_NUM_OF_POLL_FDS];
 	int poll_fd_cnt;
-
+	bool rt_kernel;
 	cthd_kobj_uevent kobj_uevent;
 
 	int proc_message(message_capsul_t *msg);
 	void process_pref_change();
 	void thermal_zone_change(message_capsul_t *msg);
 	void process_terminate();
+	void check_for_rt_kernel();
 
 public:
 	static const int max_thermal_zones = 10;
@@ -217,7 +218,9 @@ public:
 		zones.push_back(zone);
 	}
 
-	;
+	bool rt_kernel_status() {
+		return rt_kernel;
+	}
 };
 
 #endif /* THD_ENGINE_H_ */
diff --git a/src/thd_zone_cpu.cpp b/src/thd_zone_cpu.cpp
index 3b4eaf8..9ed0767 100644
--- a/src/thd_zone_cpu.cpp
+++ b/src/thd_zone_cpu.cpp
@@ -229,16 +229,20 @@ int cthd_zone_cpu::zone_bind_sensors() {
 	if (init() != THD_SUCCESS)
 		return THD_ERROR;
 
-	sensor = thd_engine->search_sensor("pkg-temp-0");
-	if (sensor) {
-		bind_sensor(sensor);
-		async_sensor = true;
+	if (!thd_engine->rt_kernel_status()) {
+		sensor = thd_engine->search_sensor("pkg-temp-0");
+		if (sensor) {
+			bind_sensor(sensor);
+			async_sensor = true;
+		}
 	}
 
-	sensor = thd_engine->search_sensor("x86_pkg_temp");
-	if (sensor) {
-		bind_sensor(sensor);
-		async_sensor = true;
+	if (!thd_engine->rt_kernel_status()) {
+		sensor = thd_engine->search_sensor("x86_pkg_temp");
+		if (sensor) {
+			bind_sensor(sensor);
+			async_sensor = true;
+		}
 	}
 
 	sensor = thd_engine->search_sensor("soc_dts0");
-- 
1.9.1

