From eeadf7d2efe557ac57363e75d14ffcf262651dca Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Thu, 9 Jan 2020 18:15:26 -0800
Subject: [PATCH] Restore to min state on deactivation without depending on
 hardware state
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

There is one issue with the current code when temperature doesn't drop
quickly to less than 20%, system will be in constrained state for
longer interval.

Let's say the min state is 25W, max in 10W and there is trip is at 40C for
skin, which takes long time to cool. Suppose the current power consumption
is 20W and current temp > 40C. So the exponential controller will reduce
the power and reach a state where the current temp < 40C. Suppose the
power at that point is 15W which forced by the hardware. So when the temp
is < 40C, we expect the power setting to go back to 25W stepwise. The current
logic will limit to 15W.

To fix this separate the call to read current state for activation and
deactivation. When activate read the current hardware state, and reduce
from it. But when deactivate start from the last state set during
activation, which  is a logical state, so this can be taken upto
min_state.
---
 src/thd_cdev.cpp      | 118 ++++++++++++++++++++++++------------------
 src/thd_cdev.h        |   3 +-
 src/thd_cdev_rapl.cpp |  19 +++----
 3 files changed, 77 insertions(+), 63 deletions(-)

diff --git a/src/thd_cdev.cpp b/src/thd_cdev.cpp
index 0c0238f..17a9000 100644
--- a/src/thd_cdev.cpp
+++ b/src/thd_cdev.cpp
@@ -39,73 +39,91 @@
 #include "thd_cdev.h"
 #include "thd_engine.h"
 
+int cthd_cdev::thd_clamp_state_min(int _state)
+{
+	if ((min_state < max_state && _state < min_state)
+			|| (min_state > max_state && _state > min_state))
+		return min_state;
+	else
+		return _state;
+}
+
+int cthd_cdev::thd_clamp_state_max(int _state)
+{
+	if ((min_state < max_state && _state > max_state)
+			|| (min_state > max_state && _state < max_state))
+		return max_state;
+	else
+		return _state;
+}
+
 int cthd_cdev::thd_cdev_exponential_controller(int set_point, int target_temp,
 		int temperature, int state, int zone_id) {
 
 	int control = state;
+	int curr_state, max_state, _state;
 
-	curr_state = get_curr_state();
-	if ((min_state < max_state && curr_state < min_state)
-			|| (min_state > max_state && curr_state > min_state))
-		curr_state = min_state;
 	max_state = get_max_state();
-	thd_log_debug("thd_cdev_set_%d:curr state %d max state %d\n", index,
-			curr_state, max_state);
+
 	if (state) {
-		if ((min_state < max_state && curr_state < max_state)
-				|| (min_state > max_state && curr_state > max_state)) {
-			int state;
+		// Get the latest state, which for some devices read the state from the hardware
+		curr_state = get_curr_state(true);
+		// Clamp the current state to min_state, as we start from min to max for
+		// activation of a cooling device
+		curr_state = thd_clamp_state_min(curr_state);
+		thd_log_debug("thd_cdev_set_%d:curr state %d max state %d\n", index,
+				curr_state, max_state);
+
+		if (inc_val)
+			_state = curr_state + inc_val;
+		else
+			_state = curr_state + inc_dec_val;
+
+		if (trend_increase) {
+			// This means this is a repeat call for activation
+			if (curr_pow == 0)
+				base_pow_state = curr_state;
+			++curr_pow;
 
 			if (inc_val)
-				state = curr_state + inc_val;
+				_state = base_pow_state + int_2_pow(curr_pow) * inc_val;
 			else
-				state = curr_state + inc_dec_val;
-			if (trend_increase) {
-				if (curr_pow == 0)
-					base_pow_state = curr_state;
-				++curr_pow;
-
-				if (inc_val)
-					state = base_pow_state + int_2_pow(curr_pow) * inc_val;
-				else
-					state = base_pow_state + int_2_pow(curr_pow) * inc_dec_val;
-
-				thd_log_info(
-						"cdev index:%d consecutive call, increment exponentially state %d (min %d max %d)\n",
-						index, state, min_state, max_state);
-				if ((min_state < max_state && state >= max_state)
-						|| (min_state > max_state && state <= max_state)) {
-					state = max_state;
-					curr_pow = 0;
-					curr_state = max_state;
-				}
-			} else {
-				curr_pow = 0;
-			}
-			trend_increase = true;
-			if ((min_state < max_state && state > max_state)
-					|| (min_state > max_state && state < max_state))
-				state = max_state;
-			thd_log_debug("op->device:%s %d\n", type_str.c_str(), state);
-			set_curr_state(state, control);
+				_state = base_pow_state + int_2_pow(curr_pow) * inc_dec_val;
+
+			thd_log_info(
+					"cdev index:%d consecutive call, increment exponentially state %d (min %d max %d)\n",
+					index, _state, min_state, max_state);
+
+			// Make sure that the state is not beyond max_state
+			_state = thd_clamp_state_max(_state);
+		} else {
+			curr_pow = 0;
 		}
+		trend_increase = true;
+		thd_log_debug("op->device:%s %d\n", type_str.c_str(), _state);
+		set_curr_state(_state, control);
 	} else {
+		// Get the latest state, which is not the latest from the hardware but last set state to the device
+		curr_state = get_curr_state();
+		curr_state = thd_clamp_state_max(curr_state);
+
+		thd_log_debug("thd_cdev_set_%d:curr state %d max state %d\n", index,
+				curr_state, max_state);
+
 		curr_pow = 0;
 		trend_increase = false;
-		if (((min_state < max_state && curr_state > min_state)
-				|| (min_state > max_state && curr_state < min_state))
-				&& auto_down_adjust == false) {
-			int state;
+
+		if (auto_down_adjust == false) {
 
 			if (dec_val)
-				state = curr_state - dec_val;
+				_state = curr_state - dec_val;
 			else
-				state = curr_state - inc_dec_val;
-			if ((min_state < max_state && state < min_state)
-					|| (min_state > max_state && state > min_state))
-				state = min_state;
-			thd_log_debug("op->device:%s %d\n", type_str.c_str(), state);
-			set_curr_state(state, control);
+				_state = curr_state - inc_dec_val;
+
+			// Make sure that it is not beyond min_state
+			_state = thd_clamp_state_min(_state);
+			thd_log_info("op->device:%s %d\n", type_str.c_str(), _state);
+			set_curr_state(_state, control);
 		} else {
 			thd_log_debug("op->device: force min %s %d\n", type_str.c_str(),
 					min_state);
diff --git a/src/thd_cdev.h b/src/thd_cdev.h
index ca931d0..c7fb5f3 100644
--- a/src/thd_cdev.h
+++ b/src/thd_cdev.h
@@ -79,7 +79,8 @@ private:
 	}
 	int thd_cdev_exponential_controller(int set_point, int target_temp,
 			int temperature, int state, int arg);
-
+	int thd_clamp_state_min(int _state);
+	int thd_clamp_state_max(int _state);
 public:
 	static const int default_debounce_interval = 2; // In seconds
 	cthd_cdev(unsigned int _index, std::string control_path) :
diff --git a/src/thd_cdev_rapl.cpp b/src/thd_cdev_rapl.cpp
index 4a7fb01..410d7c4 100644
--- a/src/thd_cdev_rapl.cpp
+++ b/src/thd_cdev_rapl.cpp
@@ -48,9 +48,6 @@ void cthd_sysfs_cdev_rapl::set_curr_state(int state, int control) {
 	if (state < max_state)
 		new_state = max_state;
 
-	if (!control && state <= max_state)
-		new_state = min_state;
-
 	if (new_state >= min_state) {
 		std::stringstream time_window_attr;
 
@@ -97,20 +94,18 @@ void cthd_sysfs_cdev_rapl::set_curr_state_raw(int state, int arg) {
 	set_curr_state(state, arg);
 }
 
+// Return the last state or power set during set_curr_state
 int cthd_sysfs_cdev_rapl::get_curr_state() {
-	if (dynamic_phy_max_enable) {
-		if (constrained)
-			return thd_engine->rapl_power_meter.rapl_action_get_power(
-					PACKAGE);
-		else
-			return min_state;
-	}
 	return curr_state;
 }
 
+// Return the current power, using this the controller can choose the next state
 int cthd_sysfs_cdev_rapl::get_curr_state(bool read_again) {
-	thd_engine->rapl_power_meter.rapl_start_measure_power();
-	return thd_engine->rapl_power_meter.rapl_action_get_power(PACKAGE);
+	if (dynamic_phy_max_enable) {
+		thd_engine->rapl_power_meter.rapl_start_measure_power();
+		return thd_engine->rapl_power_meter.rapl_action_get_power(PACKAGE);
+	}
+	return curr_state;
 }
 
 int cthd_sysfs_cdev_rapl::get_max_state() {
-- 
2.25.1

